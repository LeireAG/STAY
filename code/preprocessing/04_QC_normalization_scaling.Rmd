# Aim: Quality control, normalization and scaling of the data

```{r}
# Load packages
library(semla)
library(ggplot2)
library(tidyverse)
library(dplyr)
```

```{r}
# Load data (Seurat object with corrected image size and path annotations) 
vis_mod <- readRDS(file = paste0("my_path_to_Seurat_object", "vis_mod_anno.rds"))
```

```{r}
# Load data (Seurat object with corrected image size and path annotations) and filtered spots artifacts
vis_mod <- readRDS(file = paste0("my_path_to_Seurat_object", "vis_mod_nmf_decon.rds"))
```

1.QC

```{r}
#This coerces the Spatial assay into a classic Seurat RNA assay, and stores it as "RNA3" in your object.
names(vis_mod@assays)
vis_mod[["RNA3"]] <- as(object = vis_mod[["Spatial"]], Class = "Assay")

names(vis_mod@assays) # check that an additional assay called "RNA3" is created
```

```{r}
# Mitochondrial
mt.genes <- grep(pattern = "^MT-", x = rownames(vis_mod), value = TRUE)
vis_mod$percent.mito <- (Matrix::colSums(vis_mod@assays$RNA@counts[mt.genes,])/Matrix::colSums(vis_mod@assays$RNA@counts))*100
head(vis_mod$percent.mito) # There is only 1 to 5% of mitochrondial genes cause these are not included in the 10x gen pannel.

mito_summary <- vis_mod@meta.data %>%
  dplyr::group_by(patient_method) %>%           # or patient_method, or whatever identifies your section
  dplyr::summarise(
    mean_percent_mito = mean(percent.mito, na.rm = TRUE),
    median_percent_mito = median(percent.mito, na.rm = TRUE),
    sd_percent_mito = sd(percent.mito, na.rm = TRUE),
    min_percent_mito = min(percent.mito, na.rm = TRUE),
    max_percent_mito = max(percent.mito, na.rm = TRUE)
  )
mito_summary

# Ribosomal
# Collect all genes coding for ribosomal proteins
rp.genes <- grep(pattern = "^RP[SL]", x = rownames(vis_mod), value = TRUE)
vis_mod$percent.ribo <- (Matrix::colSums(vis_mod@assays$RNA@counts[rp.genes,])/Matrix::colSums(vis_mod@assays$RNA@counts))*100
head(vis_mod$percent.ribo)  # There is no ribosomal genes cause these are not included in the 10x gen pannel.

ribo_summary <- vis_mod@meta.data %>%
  group_by(patient_method) %>%
  summarise(mean_percent_ribo = mean(percent.ribo, na.rm = TRUE))
ribo_summary

# Percentage hemoglobin genes - includes all genes starting with HB except HBP.
#Collect hemoglobin protein coding genes
hemo.genes <- grep(pattern = "^HB[^(P|E|S)]", x = rownames(vis_mod), value = TRUE)
vis_mod$percent.hemo <- (Matrix::colSums(vis_mod@assays$RNA@counts[hemo.genes,])/Matrix::colSums(vis_mod@assays$RNA@counts))*100
head(vis_mod$percent.hemo) # The percentage of hemo genes is like 0%

# Percentage for some platelet markers
plat.genes <- grep(pattern = "PECAM1|PF4", x = rownames(vis_mod), value = TRUE)
vis_mod$percent.plat <- (Matrix::colSums(vis_mod@assays$RNA@counts[plat.genes,])/Matrix::colSums(vis_mod@assays$RNA@counts))*100
head(vis_mod$percent.plat) #The percentage is almost 0

```

Plot QC

```{r, fig.width = 15, fig.height = 8}
feats <- c("nFeature_Spatial", "nCount_Spatial", "percent.mito", "percent.hemo")
QC_all_samples <- VlnPlot(vis_mod, group.by = "sample_id", split.by = "method", features = feats, pt.size = 0.1, ncol = 5)
QC_all_samples

png_res <- 1200
png(filename = "my_path/QC_all_samples.png", width = 15*png_res, height = 8*png_res, res = png_res);print(QC_all_samples);dev.off()
```

Plot spatially to understand ViolinPlots

```{r}
m <- MapFeatures(vis_mod, features = "percent.mito", cols = c("lightgray", "mistyrose", "red", "dark red", "black"), pt.size = 0.1, ncol = 4) #something is happening with the pt.size
m
```

#### Save object

```{r}
saveRDS(vis_mod,
        file = paste0("/my_path/", "vis_mod_anno_QC.rds"))
```

2. Normalize Data and Find Variable Genes. 
```{r}
# Normalize data and find top variable features
vis_mod_norm <- vis_mod |> 
  NormalizeData() |> 
#We need to define which features/genes are important in our dataset to perform PCA or clustering not necessary here. 
  FindVariableFeatures()
```

Scaling the data by centering the data and scaling (Z-score)

```{r}
#Since each gene has a different expression level, it means that genes with higher expression values will naturally have higher variation that will be captured by PCA. This means that we need to somehow give each gene a similar weight when performing PCA
vis_mod_norm <- ScaleData(vis_mod_norm)
```

2.1 Alternative - Normalizing data with SCT

```{r}
#SCTransform() models technical noise better than log-normalization (NormalizeData()), especially for variable tissue quality or library depth.
# Set the default assay to your new one
DefaultAssay(vis_mod) <- "RNA3"

# Compute total UMI counts per spot
umi <- Matrix::colSums(GetAssayData(vis_mod, assay = "RNA3", slot = "counts"))

# Identify spots with zero counts (no expression)
sum(umi == 0)  # just to check how many

# Keep only spots with >0 counts
keep_cells <- names(umi)[umi > 0]
vis_mod_wo0 <- subset(vis_mod, cells = keep_cells)

# Run SCTransform 
vis_mod_SCT <- SCTransform(vis_mod_wo0, assay = "RNA3")
```

3. Dimensionality reduction Run PCA() on variable genes to capture main sources of variation

```{r}
vis_mod_norm <- RunPCA(vis_mod_norm, npcs = 50, verbose = F)
```

```{r}
ElbowPlot(vis_mod_norm) #which help you determine how many PCs actually capture meaningful biological variation (often 10â€“30).
```

Run UMAP

```{r}
vis_mod_norm <- RunUMAP(
  vis_mod_norm,
  reduction = "pca",
  dims = 1:10, #if elbow plot suggested 10 PCs!
  n.components = 2,
  n.neighbors = 50,
  min.dist = 0.2,
  verbose = TRUE
)
# see ?RunUMAP for more info
```

Visualize UMAP

```{r}
UMAP <- DimPlot(
  vis_mod_norm,
  reduction = "umap",
  group.by = "sample_id"
) + ggplot2::ggtitle("UMAP on PCA")
UMAP

# Publicaton-friendly UMAP
UMAP2 <- DimPlot(
  vis_mod_norm,
  reduction = "umap",
  group.by = "patient",
  shape.by = "method"
) +
  scale_color_brewer(palette = "Set2") +
  theme_minimal(base_size = 14)
UMAP2

UMAP3 <- DimPlot(
  vis_mod_norm,
  reduction = "umap",
  group.by = "patient_method"
) +
 scale_color_brewer(palette = "Set2") + ggplot2::ggtitle("UMAP on PCA") +
    theme(
    panel.grid = element_blank(),                 # remove gridlines
    panel.border = element_blank(),               # remove border
    axis.line = element_line(color = "black"),    # keep clean axes
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

UMAP3

png_res <- 1200
png(filename = "//Users/leirealonso/Documents/ST/Project_Garvan_institute/Human_Breast_Cancer_Atlas/hard_vs_soft_cover/for_manuscripts/analysis/results_LA/UMAP3.png", width = 12*png_res, height = 8*png_res, res = png_res);print(UMAP3);dev.off()
```

```{r}
KRT5_plot <- MapFeatures(vis_mod_norm,
            colors = RColorBrewer::brewer.pal(n = 9, name = "Reds"),
            feature = "KRT5", 
            image_use = "raw",
            ncol = 4,
            pt_alpha = 0.5,
            scale_alpha = FALSE, 
            max_cutoff = 0.95,
            add_scalebar = T, scalebar_position = c(0.8,0.9),
            pt_stroke = NA,
            pt_size = 1,
            slot = "counts")

png_res <- 1200
png(filename = "/my_path/KRT5_plot_on_scaled_data.png", width = 15*png_res, height = 8*png_res, res = png_res);print(KRT5_plot);dev.off()
```

```{r}
#### Save object
saveRDS(vis_mod_norm,
        file = paste0("/my_path/", "vis_mod_norm.rds"))
```

